# Technical Deep Dive: AskChemist AI Integration üß†

To ensure the "AskChemist" feature is robust, helpful, and technically sound, we implemented a sophisticated integration layer between the game state and the Google Gemini API. This document details the inner workings of this system.

## 1. Architecture Overview

The integration follows a direct **Client-to-Service** pattern:
`Game Client (React)` -> `GeminiService (lib/ai.ts)` -> `Google Gemini API`

We successfully avoided the need for a backend proxy by utilizing a restricted, client-safe API key strategy (or User-provided key in initial designs).

## 2. Model Selection Logic & Diagnostics

We encountered significant challenges with model availability and quotas during development. Here is the diagnostic path we took to arrive at the final solution:

*   **Attempt 1 (`gemini-1.5-flash`)**: Resulted in **404 Not Found**. Use Case: Standard. Reason: Key constraints/tier mismatch.
*   **Attempt 2 (`gemini-2.0-flash`)**: Resulted in **429 Quota Exceeded**. Reason: "Limit: 0" for preview models on free tier keys.
*   **Attempt 3 (`gemini-2.0-flash-lite`)**: Resulted in **429 Quota Exceeded**. Reason: Same as above.
*   **Final Solution (`gemini-flash-lite-latest`)**:
    *   **Availability**: High.
    *   **Cost**: Lowest (Free Tier compatible).
    *   **Latency**: Excellent (<1s response typical).
    *   **Reasoning**: Using the `latest` generic alias ensures Google automatically routes us to the most performant available model for our tier without hardcoding a specific version hash that might be deprecated.

## 3. Prompt Engineering Strategy

The core intelligence comes from the **Context-Injection Prompt**. We do not simply send the user's question. We wrap it in a "System Instruction" block that contains the entire game reality.

### The `createChatPrompt` Template

```typescript
function createChatPrompt(query: string, gameState: GameState): string {
    return `
    You are "Ahli Kimia AI", a helpful and wise chemistry mentor...
    
    PLAYER QUESTION: "${query}"

    CURRENT GAME CONTEXT:
    Turn: ${gameState.turnNumber}
    Player HP: ${gameState.player1.hp} (pH ${gameState.player1.ph})
    Opponent HP: ${gameState.player2.hp} (pH ${gameState.player2.ph})
    Player Hand: ${JSON.stringify(gameState.player1.hand.map(c => c.name))}
    ...
    
    GAME RULES:
    ...
    `;
}
```

### Key Techniques:
1.  **State Serialization**: We map the `hand` array to a simple list of names (`['H', 'Cl', 'O']`). We avoid sending the full massive JSON object to save tokens and reduce noise.
2.  **Persona Enforcement**: We explicitly define the persona as a "Mentor" who speaks "Bahasa Melayu".
3.  **Rule Priming**: We reiterate the core mechanics (Acid + Base = Salt) in every prompt to prevent the AI from defaulting to real-world chemistry that might contradict game logic.

## 4. Error Handling & Resilience

The `GeminiService.chat` method includes specific catch blocks for common AI API failures:

```typescript
catch (error: any) {
    if (error.message?.includes("429")) {
         return "‚ö†Ô∏è Had Kouta Dicapai..."; // User-friendly "Quota Exceeded"
    }
    if (error.message?.includes("404")) {
         return "‚ö†Ô∏è Model AI tidak dijumpai..."; // User-friendly "Not Found"
    }
    // Fallback for network issues
}
```

## 5. Future Improvements
-   **Chat History**: Currently, every request is "One-Shot". Adding `history` array would allow follow-up questions.
-   **Streaming Responses**: Implementing `generateContentStream` would allow the answer to type out in real-time for a better UX.
-   **Tool Use**: We could give the AI "Tools" (Function Calling) to actually *perform* actions (e.g., "Play the Acid card for me") rather than just advising.

---
*Document generated by Antigravity Agent on 2026-01-02*
